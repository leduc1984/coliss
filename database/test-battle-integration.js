const fs = require('fs');
const path = require('path');

/**
 * Script de test d'int√©gration pour le syst√®me de bataille Pok√©mon MMO
 * V√©rifie que tous les composants sont correctement int√©gr√©s
 */
class BattleSystemIntegrationTest {
    constructor() {
        this.testResults = [];
        this.errors = [];
        this.warnings = [];
        this.workspaceRoot = path.resolve(__dirname, '..');
    }

    /**
     * Lance tous les tests d'int√©gration
     */
    async runAllTests() {
        console.log('üß™ D√©marrage des tests d\'int√©gration du syst√®me de bataille...\n');
        
        try {
            // Tests de structure de fichiers
            await this.testFileStructure();
            
            // Tests de configuration
            await this.testConfigurations();
            
            // Tests de base de donn√©es
            await this.testDatabaseIntegration();
            
            // Tests de frontend
            await this.testFrontendIntegration();
            
            // Tests de backend
            await this.testBackendIntegration();
            
            // Tests de sprites
            await this.testSpriteSystem();
            
            // G√©n√©ration du rapport
            this.generateTestReport();
            
            console.log('‚úÖ Tests d\'int√©gration termin√©s !');
            
        } catch (error) {
            console.error('üí• Erreur lors des tests :', error);
            this.errors.push(`Test failure: ${error.message}`);
        }
    }

    /**
     * Teste la structure des fichiers
     */
    async testFileStructure() {
        console.log('üìÅ Test de la structure des fichiers...');
        
        const requiredFiles = [
            'public/js/battle-sprite-manager.js',
            'public/js/battle-interface.js',
            'public/js/battle-animation-manager.js',
            'public/css/battle-interface.css',
            'public/css/battle-animations.css',
            'services/BattleService.js',
            'database/battle_tables.sql',
            'database/migrate-pokemon-data.js'
        ];
        
        for (const file of requiredFiles) {
            const filePath = path.join(this.workspaceRoot, file);
            
            if (fs.existsSync(filePath)) {
                this.addTestResult(`‚úÖ Fichier pr√©sent: ${file}`);
            } else {
                this.addError(`‚ùå Fichier manquant: ${file}`);
            }
        }
        
        // V√©rifier le dossier des sprites
        const spritePath = path.join(this.workspaceRoot, 'poke-battle/battle/images/animated/pokemon/battlesprites');
        if (fs.existsSync(spritePath)) {
            const spriteFiles = fs.readdirSync(spritePath).filter(f => f.endsWith('.gif'));
            this.addTestResult(`‚úÖ Dossier sprites: ${spriteFiles.length} sprites trouv√©s`);
            
            if (spriteFiles.length < 10) {
                this.addWarning(`‚ö†Ô∏è Peu de sprites disponibles (${spriteFiles.length})`);
            }
        } else {
            this.addError('‚ùå Dossier sprites manquant');
        }
        
        console.log('üìÅ Test de structure termin√©\n');
    }

    /**
     * Teste les configurations
     */
    async testConfigurations() {
        console.log('‚öôÔ∏è Test des configurations...');
        
        // V√©rifier les fichiers de configuration des sprites
        const configFiles = [
            'poke-battle/battle/images/animated/pokemon/battlesprites/table-front-scale.txt',
            'poke-battle/battle/images/animated/pokemon/battlesprites/table-back-scale.txt',
            'poke-battle/battle/images/animated/pokemon/battlesprites/table-coordinate-mods.txt'
        ];
        
        for (const configFile of configFiles) {
            const configPath = path.join(this.workspaceRoot, configFile);
            
            if (fs.existsSync(configPath)) {
                try {
                    const content = fs.readFileSync(configPath, 'utf8');
                    const lines = content.split('\n').filter(line => line.trim() && !line.startsWith(';'));
                    
                    this.addTestResult(`‚úÖ Config ${path.basename(configFile)}: ${lines.length} entr√©es`);
                } catch (error) {
                    this.addError(`‚ùå Erreur lecture config ${configFile}: ${error.message}`);
                }
            } else {
                this.addError(`‚ùå Fichier config manquant: ${configFile}`);
            }
        }
        
        console.log('‚öôÔ∏è Test des configurations termin√©\n');
    }

    /**
     * Teste l'int√©gration de la base de donn√©es
     */
    async testDatabaseIntegration() {
        console.log('üóÑÔ∏è Test d\'int√©gration base de donn√©es...');
        
        try {
            const { pool } = require('./migrate');
            const client = await pool.connect();
            
            try {
                // Test de connexion
                this.addTestResult('‚úÖ Connexion base de donn√©es OK');
                
                // V√©rifier les tables de bataille
                const tableCheck = await client.query(`
                    SELECT table_name 
                    FROM information_schema.tables 
                    WHERE table_schema = 'public' 
                    AND table_name IN ('pokemon_species', 'moves', 'pokemon', 'battles', 'battle_logs')
                `);
                
                const existingTables = tableCheck.rows.map(row => row.table_name);
                const requiredTables = ['pokemon_species', 'moves', 'pokemon', 'battles', 'battle_logs'];
                
                for (const table of requiredTables) {
                    if (existingTables.includes(table)) {
                        this.addTestResult(`‚úÖ Table ${table} pr√©sente`);
                    } else {
                        this.addError(`‚ùå Table ${table} manquante`);
                    }
                }
                
                // V√©rifier les donn√©es de base
                const speciesCount = await client.query('SELECT COUNT(*) FROM pokemon_species');
                const movesCount = await client.query('SELECT COUNT(*) FROM moves');
                
                this.addTestResult(`‚úÖ Esp√®ces Pok√©mon: ${speciesCount.rows[0].count}`);
                this.addTestResult(`‚úÖ Attaques: ${movesCount.rows[0].count}`);
                
                if (parseInt(speciesCount.rows[0].count) === 0) {
                    this.addWarning('‚ö†Ô∏è Aucune esp√®ce Pok√©mon en base - ex√©cuter migrate-pokemon-data.js');
                }
                
            } finally {
                client.release();
            }
            
        } catch (error) {
            this.addError(`‚ùå Erreur base de donn√©es: ${error.message}`);
        }
        
        console.log('üóÑÔ∏è Test base de donn√©es termin√©\n');
    }

    /**
     * Teste l'int√©gration frontend
     */
    async testFrontendIntegration() {
        console.log('üñ•Ô∏è Test d\'int√©gration frontend...');
        
        // V√©rifier l'inclusion des scripts dans index.html
        const indexPath = path.join(this.workspaceRoot, 'public/index.html');
        
        if (fs.existsSync(indexPath)) {
            const content = fs.readFileSync(indexPath, 'utf8');
            
            const requiredScripts = [
                'battle-sprite-manager.js',
                'battle-animation-manager.js',
                'battle-interface.js'
            ];
            
            for (const script of requiredScripts) {
                if (content.includes(script)) {
                    this.addTestResult(`‚úÖ Script ${script} inclus dans index.html`);
                } else {
                    this.addError(`‚ùå Script ${script} non inclus dans index.html`);
                }
            }
            
            // V√©rifier les CSS
            if (content.includes('battle-interface.css') || content.includes('battle-animations.css')) {
                this.addTestResult('‚úÖ CSS de bataille r√©f√©renc√©');
            } else {
                this.addWarning('‚ö†Ô∏è CSS de bataille non r√©f√©renc√© directement (chargement dynamique OK)');
            }
            
        } else {
            this.addError('‚ùå index.html manquant');
        }
        
        // Analyser les fichiers JavaScript
        this.analyzeJavaScriptFile('public/js/battle-sprite-manager.js', 'BattleSpriteManager');
        this.analyzeJavaScriptFile('public/js/battle-interface.js', 'BattleInterface');
        this.analyzeJavaScriptFile('public/js/battle-animation-manager.js', 'BattleAnimationManager');
        
        console.log('üñ•Ô∏è Test frontend termin√©\n');
    }

    /**
     * Teste l'int√©gration backend
     */
    async testBackendIntegration() {
        console.log('üîß Test d\'int√©gration backend...');
        
        // Analyser BattleService
        const battleServicePath = path.join(this.workspaceRoot, 'services/BattleService.js');
        
        if (fs.existsSync(battleServicePath)) {
            const content = fs.readFileSync(battleServicePath, 'utf8');
            
            const requiredMethods = [
                'initiateBattle',
                'processMove',
                'broadcastMoveAnimation',
                'endBattle'
            ];
            
            for (const method of requiredMethods) {
                if (content.includes(method)) {
                    this.addTestResult(`‚úÖ M√©thode ${method} pr√©sente dans BattleService`);
                } else {
                    this.addError(`‚ùå M√©thode ${method} manquante dans BattleService`);
                }
            }
            
            // V√©rifier l'int√©gration Socket.io
            if (content.includes('socket.emit') && content.includes('battle_')) {
                this.addTestResult('‚úÖ √âv√©nements Socket.io de bataille configur√©s');
            } else {
                this.addWarning('‚ö†Ô∏è √âv√©nements Socket.io de bataille √† v√©rifier');
            }
            
        } else {
            this.addError('‚ùå BattleService.js manquant');
        }
        
        // V√©rifier l'int√©gration dans server.js
        const serverPath = path.join(this.workspaceRoot, 'server.js');
        
        if (fs.existsSync(serverPath)) {
            const content = fs.readFileSync(serverPath, 'utf8');
            
            if (content.includes('BattleService')) {
                this.addTestResult('‚úÖ BattleService int√©gr√© dans server.js');
            } else {
                this.addWarning('‚ö†Ô∏è BattleService √† int√©grer dans server.js');
            }
            
        } else {
            this.addError('‚ùå server.js manquant');
        }
        
        console.log('üîß Test backend termin√©\n');
    }

    /**
     * Teste le syst√®me de sprites
     */
    async testSpriteSystem() {
        console.log('üé® Test du syst√®me de sprites...');
        
        const spritePath = path.join(this.workspaceRoot, 'poke-battle/battle/images/animated/pokemon/battlesprites');
        
        if (fs.existsSync(spritePath)) {
            const files = fs.readdirSync(spritePath);
            
            // Tester quelques sprites de r√©f√©rence
            const testSprites = [
                '001-front-n.gif',  // Bulbasaur
                '001-back-n.gif',
                '025-front-n.gif',  // Pikachu
                '025-back-n.gif'
            ];
            
            let foundSprites = 0;
            
            for (const sprite of testSprites) {
                if (files.includes(sprite)) {
                    this.addTestResult(`‚úÖ Sprite de test ${sprite} pr√©sent`);
                    foundSprites++;
                } else {
                    this.addWarning(`‚ö†Ô∏è Sprite de test ${sprite} manquant`);
                }
            }
            
            if (foundSprites >= 2) {
                this.addTestResult('‚úÖ Sprites de base disponibles pour les tests');
            } else {
                this.addError('‚ùå Pas assez de sprites de base pour les tests');
            }
            
            // Analyser les patterns de nommage
            const frontSprites = files.filter(f => f.includes('-front-') && f.endsWith('.gif'));
            const backSprites = files.filter(f => f.includes('-back-') && f.endsWith('.gif'));
            
            this.addTestResult(`‚úÖ Sprites front: ${frontSprites.length}`);
            this.addTestResult(`‚úÖ Sprites back: ${backSprites.length}`);
            
        }
        
        console.log('üé® Test sprites termin√©\n');
    }

    /**
     * Analyse un fichier JavaScript
     */
    analyzeJavaScriptFile(filePath, expectedClass) {
        const fullPath = path.join(this.workspaceRoot, filePath);
        
        if (fs.existsSync(fullPath)) {
            try {
                const content = fs.readFileSync(fullPath, 'utf8');
                
                if (content.includes(`class ${expectedClass}`)) {
                    this.addTestResult(`‚úÖ Classe ${expectedClass} d√©finie`);
                } else {
                    this.addError(`‚ùå Classe ${expectedClass} non trouv√©e dans ${filePath}`);
                }
                
                if (content.includes('constructor')) {
                    this.addTestResult(`‚úÖ Constructeur pr√©sent dans ${expectedClass}`);
                }
                
                // Compter les m√©thodes (approximatif)
                const methodCount = (content.match(/^\s+[a-zA-Z_][a-zA-Z0-9_]*\s*\(/gm) || []).length;
                this.addTestResult(`‚úÖ ${expectedClass}: ~${methodCount} m√©thodes d√©tect√©es`);
                
            } catch (error) {
                this.addError(`‚ùå Erreur analyse ${filePath}: ${error.message}`);
            }
        }
    }

    /**
     * Ajoute un r√©sultat de test
     */
    addTestResult(result) {
        this.testResults.push(result);
    }

    /**
     * Ajoute une erreur
     */
    addError(error) {
        this.errors.push(error);
        console.log(error);
    }

    /**
     * Ajoute un avertissement
     */
    addWarning(warning) {
        this.warnings.push(warning);
        console.log(warning);
    }

    /**
     * G√©n√®re le rapport de test
     */
    generateTestReport() {
        const reportPath = path.join(__dirname, 'battle_integration_test_report.txt');
        
        const report = [
            '='.repeat(80),
            'RAPPORT DE TEST D\'INT√âGRATION - SYST√àME DE BATAILLE POK√âMON MMO',
            '='.repeat(80),
            `Date: ${new Date().toISOString()}`,
            `Total des tests: ${this.testResults.length}`,
            `Erreurs: ${this.errors.length}`,
            `Avertissements: ${this.warnings.length}`,
            '',
            'R√âSULTATS DES TESTS:',
            '-'.repeat(40),
            ...this.testResults,
            '',
            'ERREURS:',
            '-'.repeat(40),
            ...this.errors,
            '',
            'AVERTISSEMENTS:',
            '-'.repeat(40),
            ...this.warnings,
            '',
            'R√âSUM√â:',
            '-'.repeat(40),
            this.errors.length === 0 ? '‚úÖ TOUS LES TESTS CRITIQUES PASS√âS' : '‚ùå ERREURS CRITIQUES D√âTECT√âES',
            this.warnings.length === 0 ? '‚úÖ AUCUN AVERTISSEMENT' : `‚ö†Ô∏è ${this.warnings.length} AVERTISSEMENT(S)`,
            '',
            'PROCHAINES √âTAPES:',
            '-'.repeat(40),
            this.errors.length > 0 ? '1. Corriger les erreurs critiques list√©es ci-dessus' : '1. ‚úÖ Tous les composants critiques sont pr√©sents',
            this.warnings.length > 0 ? '2. Examiner et r√©soudre les avertissements si n√©cessaire' : '2. ‚úÖ Aucun avertissement √† traiter',
            '3. Effectuer des tests manuels du syst√®me de bataille',
            '4. Optimiser les performances si n√©cessaire',
            '5. D√©ployer en production',
            '',
            '='.repeat(80)
        ].join('\n');
        
        fs.writeFileSync(reportPath, report);
        
        console.log('\n' + '='.repeat(60));
        console.log('üìä R√âSUM√â DU TEST D\'INT√âGRATION');
        console.log('='.repeat(60));
        console.log(`‚úÖ Tests r√©ussis: ${this.testResults.length}`);
        console.log(`‚ùå Erreurs: ${this.errors.length}`);
        console.log(`‚ö†Ô∏è Avertissements: ${this.warnings.length}`);
        
        if (this.errors.length === 0) {
            console.log('\nüéâ INT√âGRATION R√âUSSIE ! Le syst√®me de bataille est pr√™t.');
        } else {
            console.log('\n‚ö†Ô∏è INT√âGRATION INCOMPL√àTE - Voir les erreurs ci-dessus.');
        }
        
        console.log(`\nüìÑ Rapport d√©taill√©: ${reportPath}`);
    }

    /**
     * Teste les performances (test basique)
     */
    async testPerformance() {
        console.log('üèÉ Test de performance basique...');
        
        // Test de chargement des sprites (simulation)
        const start = Date.now();
        
        // Simuler le chargement de plusieurs sprites
        for (let i = 0; i < 10; i++) {
            // Simulation d'op√©ration asynchrone
            await new Promise(resolve => setTimeout(resolve, 10));
        }
        
        const elapsed = Date.now() - start;
        
        if (elapsed < 500) {
            this.addTestResult(`‚úÖ Performance simul√©e: ${elapsed}ms (Bon)`);
        } else {
            this.addWarning(`‚ö†Ô∏è Performance simul√©e: ${elapsed}ms (√Ä optimiser)`);
        }
        
        console.log('üèÉ Test de performance termin√©\n');
    }
}

// Fonction principale
async function main() {
    const tester = new BattleSystemIntegrationTest();
    await tester.runAllTests();
    
    // Code de sortie bas√© sur les r√©sultats
    process.exit(tester.errors.length > 0 ? 1 : 0);
}

// Exporter et ex√©cuter si appel√© directement
module.exports = BattleSystemIntegrationTest;

if (require.main === module) {
    main().catch(error => {
        console.error('üí• Erreur fatale lors des tests:', error);
        process.exit(1);
    });
}